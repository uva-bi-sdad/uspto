---
title: "Analyze Inventor Features Using PatentsView Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyze Inventor Features Using PatentsView Data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

*Built with R 
`r getRversion()`*

***

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 6,
  fig.width = 8.84,
  dev = "CairoSVG",
  fig.ext = "svg"
)
library(uspto)
library(knitr)
library(lusilab)
library(sf)
outDir <- "../patentsview/"
if (!dir.exists(outDir)) outDir <- "../../patentsview/"
```

```{css, echo = FALSE}
.table {margin-bottom: 40px}
td {white-space: nowrap}
```

This example explores the [PatentsView](https://patentsview.org) bulk tables, with a focus on
assigned inventor sex.

## Setup

Before starting, we'll need to load the package, and point to a directory where we'd like things saved:
```r
# install if needed: remotes::install_guthub("uva-bi-sdad/uspto")
library(uspto)
outDir <- "../patentsview/"
```

## Which patent categories have most and fewest female inventors?

The first step toward answering this question is to assign a sex to inventors
based on their given name. The inventors table includes USPTO's assignment,
which we'll start with:
```{r}
# you may need to increase your download timeout, depending on your connection
options(timeout = 300)

inventors <- as.data.frame(download_patentsview_bulk("inventor", outDir))
```

Now, we can add a few of our own prediction methods, including one based on
the included USPTO flags:
```{r}
# associate a sex with each unique given name
inventor_sex_file <- paste0(outDir, "inventor_sex.csv.xz")
if (file.exists(inventor_sex_file)) {
  inventor_sex <- vroom::vroom(inventor_sex_file, show_col_types = FALSE)
} else {
  # add a standardized version of given names
  inventors$name_first[is.na(inventors$name_first)] <- ""
  inventors$given <- sub(
    "^(.)", "\\U\\1", gsub("^([a-z-]{,6}[.-])+ | +.*", "", tolower(inventors$name_first)),
    perl = TRUE
  )
  inventors$name_last[is.na(inventors$name_last)] <- ""
  inventors$family <- sub(
    "^(.)", "\\U\\1", gsub("^([a-z-]{,6}[.-])+ | +.*", "", tolower(inventors$name_last)),
    perl = TRUE
  )

  # reverse male flag
  inventors$pred_fem_patentsview <- inventors$male_flag
  inventors$pred_fem_patentsview[is.na(inventors$pred_fem_patentsview)] <- .5
  inventors$pred_fem_patentsview <- 1 - inventors$pred_fem_patentsview

  ## install if needed: remotes::install_github("miserman/lusilab")
  library(lusilab)
  inventor_sex <- cbind(
    inventors[, c("id", "given", "family", "pred_fem_patentsview")], predict_demographics(
      inventors$given, inventors$name_last,
      dir = paste0(dirname(outDir), "/names")
    )[, -(1:3)]
  )

  ## make aggregate predictor
  count_vars <- grep("count_", colnames(inventor_sex), fixed = TRUE, value = TRUE)
  inventor_sex$prob_fem <- rowSums(
    inventor_sex[, count_vars] * inventor_sex[, sub("count", "prob_fem", count_vars, fixed = TRUE)]
  ) / rowSums(inventor_sex[, count_vars])

  vroom::vroom_write(inventor_sex, inventor_sex_file, ",")
}

# get categorical predictions
prob_cols <- grep("^prob_", colnames(inventor_sex), value = TRUE)
inventor_sex_preds <- as.data.frame(inventor_sex[, prob_cols])
dimnames(inventor_sex_preds) <- list(
  inventor_sex$id,
  sub("prob", "pred", prob_cols, fixed = TRUE)
)
inventor_sex_preds[inventor_sex_preds > .5] <- 1
inventor_sex_preds[inventor_sex_preds < .5] <- 0
```

First, we can compare these different methods with the USPTO assignments:
```{r}
kable(
  data.frame(
    "Proportion Sexed" = colMeans(inventor_sex_preds != .5),
    "Accuracy of Sexed to PatentsView" = colMeans(vapply(
      inventor_sex_preds, function(x) x != .5 & x == inventor_sex$pred_fem_patentsview,
      logical(nrow(inventor_sex))
    )),
    check.names = FALSE
  ),
  caption = "Sex Predition Method Comparisons"
)
```

Now we can move forward with the method with the aggregate prediction:
```{r}
# add assigned sex to inventors data
inventors$pred_fem <- inventor_sex_preds$pred_fem

## focus on just sexed inventors
inventors <- inventors[inventors$pred_fem != .5, ]
rownames(inventors) <- inventors$id

# add patent IDs
patent_inventor <- download_patentsview_bulk("patent_inventor", outDir)
patent_inventor <- patent_inventor[patent_inventor$inventor_id %in% inventors$id, ]
inventors <- cbind(inventors[patent_inventor$inventor_id, -1], patent_inventor)

# count inventors predicted to be female in each patent
female_inventors <- tapply(inventors$pred_fem == 1, inventors$patent_id, sum)
```

### World Intellectual Property Organization

Now we can add patent category information, to get breakdowns of classes by inventor sex.
There are multiple classification schemes, but we can start with the
World Intellectual Property Organization (WIPO) technology fields for a high-level overview:
```{r}
library(Matrix)

# this makes a patent x WIPO category matrix
categories_wipo <- patentsview_class_matrix("wipo", paste0(outDir, "wipo_matrix.rds"), dir = outDir)
dim(categories_wipo)

# which we can join to the inventors matrix
inventors_wipo <- female_inventors[names(female_inventors) %in% rownames(categories_wipo)]
inventors_wipo <- cbind(as.numeric(inventors_wipo), categories_wipo[names(inventors_wipo), ])

# and get category breakdowns by inventor sex
wipo_summary <- data.frame(
  Any_Female = colSums(inventors_wipo[inventors_wipo[, 1] != 0, -1] != 0),
  No_Female = colSums(inventors_wipo[inventors_wipo[, 1] == 0, -1] != 0)
)
wipo_summary <- cbind(wipo_summary, sweep(wipo_summary, 2, colSums(wipo_summary), "/") * 100)
colnames(wipo_summary)[3:4] <- c("Any_Female_Percent", "No_Female_Percent")
wipo_summary$Difference <- wipo_summary$Any_Female_Percent - wipo_summary$No_Female_Percent
wipo_summary <- wipo_summary[order(-wipo_summary$Difference), ]

# add category titles
wipo_field <- as.data.frame(download_patentsview_bulk("wipo_field", outDir))
rownames(wipo_field) <- wipo_field$id
wipo_summary$Title <- wipo_field[rownames(wipo_summary), "field_title"]

kable(
  wipo_summary,
  digits = 3,
  col.names = gsub("_", " ", colnames(wipo_summary), fixed = TRUE),
  caption = "World Intellectual Property Organization Categories"
)
```

### United States Patent Classification

For a more refined classification, we might look at the United States Patent Classification (USPC),
which is most closely related to examination process:
```{r}
# get the patent x USPC category matrix
categories_uspc <- patentsview_class_matrix(
  "uspc_current", paste0(outDir, "uspc_current_matrix.rds"),
  dir = outDir
)
dim(categories_uspc)

# join to the inventors matrix
inventors_uspc <- female_inventors[names(female_inventors) %in% rownames(categories_uspc)]
inventors_uspc <- cbind(as.numeric(inventors_uspc), categories_uspc[names(inventors_uspc), ])

# and get category breakdowns by inventor sex
uspc_summary <- data.frame(
  Any_Female = colSums(inventors_uspc[inventors_uspc[, 1] != 0, -1] != 0),
  No_Female = colSums(inventors_uspc[inventors_uspc[, 1] == 0, -1] != 0)
)
uspc_summary <- cbind(uspc_summary, sweep(uspc_summary, 2, colSums(uspc_summary), "/") * 100)
colnames(uspc_summary)[3:4] <- c("Any_Female_Percent", "No_Female_Percent")
uspc_summary$Difference <- uspc_summary$Any_Female_Percent - uspc_summary$No_Female_Percent
uspc_summary <- uspc_summary[order(-uspc_summary$Difference), ]

# add category titles
uspc_field <- as.data.frame(download_patentsview_bulk("mainclass_current", outDir))
rownames(uspc_field) <- uspc_field$id
uspc_summary$Title <- uspc_field[rownames(uspc_summary), "title"]

kable(
  uspc_summary[c(1:20, 1:20 + nrow(uspc_summary) - 20), ],
  digits = 3,
  col.names = gsub("_", " ", colnames(uspc_summary), fixed = TRUE),
  caption = paste(
    "U.S. Patent Classification categories with the highest and lowest",
    "proportion of any female inventor"
  )
)
```

### How have category breakdowns changed over time?

To get at this question, we'll need to associate a date with each patent number:
```{r}
# start with all patent information
patents <- download_patentsview_bulk("patent", outDir)

# associate a date with each patent number
all_dates <- structure(patents$date, names = patents$number)

# get years, and focus on only those found in the USPC set
uspc_year <- substr(all_dates[names(all_dates) %in% rownames(inventors_uspc)], 1, 4)
```

Now we could look at trends in differences in the percent of female versus male assigned
inventors:
```{r}
# use this set of years to break down the overall summaries
uspc_yearly_summaries <- do.call(rbind, lapply(sort(unique(uspc_year)), function(year) {
  d <- inventors_uspc[names(which(uspc_year == year)), ]
  r <- data.frame(
    Any_Female = colSums(d[d[, 1] != 0, -1] != 0, na.rm = TRUE),
    No_Female = colSums(d[d[, 1] == 0, -1] != 0, na.rm = TRUE)
  )
  r <- sweep(r, 2, colSums(r), "/") * 100
  r$Difference <- r$Any_Female - r$No_Female
  c(Year = as.numeric(year), t(r[3])[1, ])
}))
uspc_yearly_summaries[is.na(uspc_yearly_summaries)] <- 0
uspc_yearly_summaries <- uspc_yearly_summaries[, colSums(uspc_yearly_summaries) != 0]

# plot categories with the most positive and negative trends
library(splot)
trends <- sort(cor(uspc_yearly_summaries[, -1], uspc_yearly_summaries[, 1])[, 1], TRUE)
splot(
  uspc_yearly_summaries[, names(trends[c(1:5, 1:4 + length(trends) - 4)])] ~ uspc_yearly_summaries[, 1],
  lines = "spline", levels = list(mv = uspc_field[names(trends[c(1:5, 1:4 + length(trends) - 4)]), "title"]),
  title = "Inventor Distribution by Assigned Sex Per USPC Class Over Time",
  laby = "Percent Female-Assigned Inventors - Male-Assigned Inventors",
  labx = "Year", leg.title = "U.S. Patent Classification", myl = c(-.6, .7)
)
```

This highlights categories that are trending toward more similar allocations of inventors by sex,
and suggests there are no categories showing a strong trend toward increasing difference in
inventor allocation by sex.

We might also look at categories that show some trend in the percent of female-assigned inventors
alone -- where a greater or lesser percentage of the female-assigned inventor workforce has been allocated:

```{r}
uspc_yearly_female_summaries <- do.call(rbind, lapply(sort(unique(uspc_year)), function(year) {
  d <- inventors_uspc[names(which(uspc_year == year)), ]
  r <- colSums(d[d[, 1] != 0, -1] != 0, na.rm = TRUE)
  r <- r / sum(r) * 100
  c(Year = as.numeric(year), r)
}))
uspc_yearly_female_summaries <- uspc_yearly_female_summaries[, colSums(uspc_yearly_female_summaries) != 0]

trends_female <- sort(cor(uspc_yearly_female_summaries[, -1], uspc_yearly_female_summaries[, 1])[, 1], TRUE)
splot(
  uspc_yearly_female_summaries[, names(trends_female[c(1:7, 1:2 + length(trends_female) - 6)])] ~
    uspc_yearly_female_summaries[, 1],
  lines = "spline", levels = list(
    mv = uspc_field[names(trends_female[c(1:7, 1:2 + length(trends_female) - 6)]), "title"]
  ),
  labels.trim = FALSE,
  title = "Share of Female-Assigned Inventors Per USPC Class Over Time", lpos = "topleft",
  laby = "Percent Female-Assigned Inventors", labx = "Year", leg.title = "U.S. Patent Classification"
)
```

### Cooperative Patent Classifications

Cooperative Patent Classifications (CPC) might give an even more refined look,
and could be compared across patent offices:
```{r}
# get the patent x CPC category matrix
categories_cpc <- patentsview_class_matrix(
  "cpc_current", paste0(outDir, "cpc_current_matrix.rds"),
  dir = outDir
)
dim(categories_cpc)

# join to the inventors matrix
inventors_cpc <- female_inventors[names(female_inventors) %in% rownames(categories_cpc)]
inventors_cpc <- cbind(as.numeric(inventors_cpc), categories_cpc[names(inventors_cpc), ])

# and get category breakdowns by inventor sex
cpc_summary <- data.frame(
  Any_Female = colSums(inventors_cpc[inventors_cpc[, 1] != 0, -1] != 0),
  No_Female = colSums(inventors_cpc[inventors_cpc[, 1] == 0, -1] != 0)
)
cpc_summary <- cbind(cpc_summary, sweep(cpc_summary, 2, colSums(cpc_summary), "/") * 100)
colnames(cpc_summary)[3:4] <- c("Any_Female_Percent", "No_Female_Percent")
cpc_summary$Difference <- cpc_summary$Any_Female_Percent - cpc_summary$No_Female_Percent
cpc_summary <- cpc_summary[order(-cpc_summary$Difference), ]

# add category titles
cpc_group <- as.data.frame(download_patentsview_bulk("cpc_group", outDir))
rownames(cpc_group) <- cpc_group$id
cpc_summary <- cpc_summary[rownames(cpc_summary) %in% cpc_group$id, ]
cpc_summary$Title <- cpc_group[rownames(cpc_summary), "title"]

cpc_selection <- names(which(rowSums(cpc_summary[, 1:2]) > 5))
cpc_selection <- cpc_selection[c(1:20, 1:20 + length(cpc_selection) - 20)]
kable(
  cpc_summary[cpc_selection, ],
  digits = 3,
  col.names = gsub("_", " ", colnames(cpc_summary), fixed = TRUE),
  caption = paste(
    "Cooperative Patent Classifications: 20 categories with the highest and lowest",
    "proportion of any female inventor with at least 5 associated patents"
  )
)
```

## Where are there most and fewest female inventors?

The locations table associates inventor IDs with location IDs:
```{r}
locations <- as.data.frame(download_patentsview_bulk("location", outDir))
locations$state_fips[!is.na(locations$state_fips)] <- formatC(
  locations$state_fips[!is.na(locations$state_fips)],
  width = 2, flag = 0, format = "d"
)
locations$county_fips[!is.na(locations$county_fips)] <- formatC(
  locations$county_fips[!is.na(locations$county_fips)],
  width = 5, flag = 0, format = "d"
)

# we can align this with our inventors data for inventor sex
rownames(locations) <- locations$id
located_inventors <- inventors[!is.na(inventors$location_id), ]
locations <- locations[located_inventors$location_id, ]
```

Inventor location is recorded as part of each patent, which means
inventors may have multiple locations over time. For an initial look,
we can focus only on each inventors most recent location:
```{r}
# add date information to inventor data
inventors$date <- structure(patents$date, names = patents$number)[inventors$patent_id]

# sort inventors by date, then add location information
inventors_last_seen <- inventors[order(inventors$date, decreasing = TRUE), ]
inventors_last_seen <- inventors_last_seen[!duplicated(inventors_last_seen$inventor_id), ]
inventors_last_seen <- inventors_last_seen[inventors_last_seen$location_id %in% locations$id, ]
inventors_last_seen <- cbind(inventors_last_seen, locations[inventors_last_seen$location_id, ])
```

Now we can look at high-level summaries of locations, like we did with patent classes:
```{r}
# top countries
breakdown_countries <- as.data.frame(t(vapply(
  split(inventors_last_seen$pred_fem, inventors_last_seen$country),
  function(d) c(Female = sum(d == 1), Male = sum(d == 0)),
  c(0, 0)
)))
breakdown_countries <- cbind(
  breakdown_countries,
  sweep(breakdown_countries, 2, colSums(breakdown_countries), "/") * 100
)
colnames(breakdown_countries)[3:4] <- c("Female_Percent", "Male_Percent")
breakdown_countries$Difference <- breakdown_countries$Female_Percent - breakdown_countries$Male_Percent
breakdown_countries <- breakdown_countries[order(-breakdown_countries$Difference), ]
kable(
  breakdown_countries[rowSums(breakdown_countries[, 1:2]) > 1e4, ],
  col.names = gsub("_", " ", colnames(breakdown_countries), fixed = TRUE),
  caption = "Countries with at least 10,000 associated inventors"
)
# top states
breakdown_states <- as.data.frame(t(vapply(
  split(inventors_last_seen$pred_fem, inventors_last_seen$state_fips),
  function(d) c(Female = sum(d == 1), Male = sum(d == 0)),
  c(0, 0)
)))
breakdown_states <- cbind(
  breakdown_states,
  sweep(breakdown_states, 2, colSums(breakdown_states), "/") * 100
)
colnames(breakdown_states)[3:4] <- c("Female_Percent", "Male_Percent")
breakdown_states$Difference <- breakdown_states$Female_Percent - breakdown_states$Male_Percent
breakdown_states <- breakdown_states[order(-breakdown_states$Difference), ]
## install if needed: remotes::install_github("uva-bi-sdad/catchment")
library(catchment)
states <- download_census_shapes(paste0(dirname(outDir), "/maps"))
state_names <- structure(states$NAME, names = states$STATEFP)
breakdown_states <- breakdown_states[rownames(breakdown_states) %in% names(state_names), ]
rownames(breakdown_states) <- state_names[rownames(breakdown_states)]
kable(
  breakdown_states[rowSums(breakdown_states[, 1:2]) > 1e4, ],
  col.names = gsub("_", " ", colnames(breakdown_states), fixed = TRUE),
  caption = "States with at least 10,000 associated inventors"
)
# map of counties
library(leaflet)
library(sf)
counties <- st_transform(download_census_shapes(
  paste0(dirname(outDir), "/maps"),
  entity = "county"
), "WGS84")
counties$NAME <- paste0(counties$NAME, ", ", state_names[counties$STATEFP])

breakdown_counties <- as.data.frame(t(vapply(
  split(inventors_last_seen$pred_fem, inventors_last_seen$county_fips),
  function(d) c(Female = sum(d == 1), Male = sum(d == 0)),
  c(0, 0)
)))
breakdown_counties <- cbind(
  breakdown_counties,
  sweep(breakdown_counties, 2, colSums(breakdown_counties), "/") * 100
)
colnames(breakdown_counties)[3:4] <- c("Female_Percent", "Male_Percent")
breakdown_counties$Difference <- breakdown_counties$Female_Percent - breakdown_counties$Male_Percent
breakdown_counties$Total <- rowSums(breakdown_counties[, 1:2])
breakdown_counties$Capped_Total <- breakdown_counties$Total
breakdown_counties$Capped_Total[breakdown_counties$Capped_Total > 5e4] <- 1e5
breakdown_counties <- breakdown_counties[counties$GEOID, ]

pal <- colorNumeric(
  scico::scico(255, direction = -1, palette = "vik"),
  rep(max(abs(breakdown_counties$Difference), na.rm = TRUE), 2) * c(-1, 1)
)
pal_total <- colorNumeric(
  scico::scico(255, direction = -1, palette = "lajolla"), breakdown_counties$Capped_Total
)
leaflet(counties[, 1], options = leafletOptions(attributionControl = FALSE)) |>
  addProviderTiles("CartoDB.Positron") |>
  setView(-95.5810546875, 39.5040407055842, 4) |>
  addControl("Percent Female-Assigned Inventors - Percent Male-Assigned Inventors", "topright") |>
  addLayersControl(position = "topleft", overlayGroups = c("Total", "Difference")) |>
  addLegend(
    "bottomright", pal_total, breakdown_counties$Capped_Total,
    opacity = 1,
    title = "Totals", group = "Total"
  ) |>
  addPolygons(
    fillColor = pal_total(breakdown_counties$Capped_Total),
    fillOpacity = .8, weight = 1, color = "#000", highlightOptions = highlightOptions(color = "#fff"),
    group = "Total", label = paste0("County: ", counties$NAME, "; Total: ", breakdown_counties$Total)
  ) |>
  hideGroup("Total") |>
  addLegend(
    "bottomright", pal, breakdown_counties$Difference,
    opacity = 1,
    title = "Percent Difference", group = "Difference"
  ) |>
  addPolygons(
    fillColor = pal(breakdown_counties$Difference), fillOpacity = .8, weight = 1, color = "#000",
    highlightOptions = highlightOptions(color = "#fff"),
    group = "Difference", label = paste0(
      "County: ", counties$NAME,
      "; Female: ", breakdown_counties$Female,
      "; Male: ", breakdown_counties$Male,
      "; Percent Difference (Female - Male): ", round(breakdown_counties$Difference, 3)
    )
  )
```

### How have inventors migrated?

Instead of collapsing inventors to a single location, we could also look for instances
of inventors moving between states, and see which moves are most common:
```{r, fig.height=10}
# start with all of located inventors
inventor_states <- cbind(
  located_inventors[, c("inventor_id", "pred_fem")],
  date = all_dates[located_inventors$patent_id],
  state = state_names[locations$state_fips]
)
inventor_states <- inventor_states[!is.na(inventor_states$state), ]
inventor_states <- inventor_states[!is.na(inventor_states$date), ]

# select only those that are associated with multiple patents
inventor_states <- inventor_states[
  inventor_states$inventor_id %in% inventor_states$inventor_id[duplicated(inventor_states$inventor_id)],
]
inventor_states <- inventor_states[order(inventor_states$date, decreasing = TRUE), ]

## see how many unique inventors this leaves
length(unique(inventor_states$inventor_id))

# then look at each inventor to see if they have more than one state.
# if they do, record their transition; previous state -> new state
inventor_history <- lapply(split(inventor_states, inventor_states$inventor_id), function(d) {
  if (!all(d$state == d$state[[1]])) {
    res <- NULL
    states <- d$state
    for (i in seq_len(nrow(d) - 1)) {
      if (states[[i]] != states[[i + 1]]) res <- c(paste(states[[i + 1]], "->", states[[i]]), res)
    }
    res
  }
})
inventor_history <- Filter(length, inventor_history)

## see how many inventors have associated moves
length(inventor_history)

inventor_moves <- unlist(inventor_history)
inventor_moves <- tapply(inventor_moves, inventor_moves, length)
inventor_transitions <- data.frame(
  do.call(rbind, strsplit(names(inventor_moves), " -> ", fixed = TRUE)),
  inventor_moves
)
colnames(inventor_transitions) <- c("from", "to", "count")

# use these transitions to make a origin x destination matrix
states <- sort(unique(c(inventor_transitions$from, inventor_transitions$to)))
migrations <- matrix(0, length(states), length(states), dimnames = list(states, states))
for (r in seq_len(nrow(inventor_transitions))) {
  move <- inventor_transitions[r, ]
  migrations[move$from, move$to] <- move$count
}
migrations <- migrations[rowSums(migrations) > 1e4, rowSums(migrations) > 1e4]
migrations <- migrations[order(-rowSums(migrations)), order(-rowSums(migrations))]

# and make a chord diagram out of the most frequently involved states
# colored by percent difference (Female - Male; higher female percent = bluer)
## devtools::install_github("mattflor/chorddiag")
library(chorddiag)
chorddiag(
  migrations,
  groupColors = scico::scico(nrow(migrations), palette = "vik")[
    order(order(-breakdown_states[rownames(migrations), "Difference"]))
  ], showTicks = FALSE, groupnamePadding = 5
)
```
